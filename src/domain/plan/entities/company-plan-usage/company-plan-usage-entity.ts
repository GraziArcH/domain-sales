import { IdValueObject } from "../../value-objects";
import { ICompanyPlanUsageRepository } from "../../interfaces/database/company-plan-usage-repository";
import { CompanyPlanUsageEntityModel, UsageMetricsEntityModel } from "./company-plan-usage-entity-model";
import { CompanyPlanUsageCreateDTO } from "./company-plan-usage-dtos";

export class CompanyPlanUsageEntity {
    constructor(private readonly repository: ICompanyPlanUsageRepository) {}

    async getByCompanyPlanId(companyPlanId: string | number): Promise<CompanyPlanUsageEntityModel[]> {
        const companyPlanIdObj = IdValueObject.create(companyPlanId);
        if (companyPlanIdObj instanceof Error) throw companyPlanIdObj;

        const usages = await this.repository.getByCompanyPlanId(companyPlanIdObj);

        return usages.map((usage) =>
            CompanyPlanUsageEntityModel.create({
                usageId: usage.usage_id.value,
                companyPlanId: usage.company_plan_id.value,
                userId: usage.user_id.value,
                admin: usage.admin,
                createdAt: usage.created_at,
                updatedAt: usage.updated_at
            })
        );
    }

    async create(data: CompanyPlanUsageCreateDTO): Promise<CompanyPlanUsageEntityModel> {
        const now = new Date();

        const entityModel = CompanyPlanUsageEntityModel.create({
            usageId: 0, // Will be generated by the database
            ...data,
            createdAt: now,
            updatedAt: now
        });

        const values = entityModel.getValues();

        const result = await this.repository.create({
            usage_id: IdValueObject.create(0) as IdValueObject,
            company_plan_id: IdValueObject.create(values.companyPlanId) as IdValueObject,
            user_id: IdValueObject.create(values.userId) as IdValueObject,
            admin: values.admin,
            created_at: values.createdAt,
            updated_at: values.updatedAt
        });

        return CompanyPlanUsageEntityModel.create({
            usageId: result.usage_id.value,
            companyPlanId: result.company_plan_id.value,
            userId: result.user_id.value,
            admin: result.admin,
            createdAt: result.created_at,
            updatedAt: result.updated_at
        });
    }

    async bulkCreate(dataArray: CompanyPlanUsageCreateDTO[]): Promise<CompanyPlanUsageEntityModel[]> {
        if (dataArray.length === 0) return [];

        const now = new Date();
        const usageModels = dataArray.map((data) => ({
            usage_id: IdValueObject.create(0) as IdValueObject,
            company_plan_id: IdValueObject.create(data.companyPlanId) as IdValueObject,
            user_id: IdValueObject.create(data.userId) as IdValueObject,
            admin: data.admin,
            created_at: now,
            updated_at: now
        }));

        const results = await this.repository.bulkCreate(usageModels);

        return results.map((result) =>
            CompanyPlanUsageEntityModel.create({
                usageId: result.usage_id.value,
                companyPlanId: result.company_plan_id.value,
                userId: result.user_id.value,
                admin: result.admin,
                createdAt: result.created_at,
                updatedAt: result.updated_at
            })
        );
    }

    async getUsageMetrics(companyId: string | number): Promise<UsageMetricsEntityModel> {
        const companyIdObj = IdValueObject.create(companyId);
        if (companyIdObj instanceof Error) throw companyIdObj;

        const metrics = await this.repository.getUsageMetrics(companyIdObj);

        return UsageMetricsEntityModel.create(metrics);
    }
}
